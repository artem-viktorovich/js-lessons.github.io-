<h1>Возможности ES6 или ECMAScript 2015</h1>

function sum(a+b) {
    return a+b
}
let date = [4,8];
sum(...date) - оператор расширения который делает вычисление данных, которые были заданы в аргументе ( sum(a+b) )
12

==========================================
<h2>Деструктивное присваивание</h2>

Зададим несколько переменных и сразу зададим им значения

let [a,b,c,d] = [10,5,8,4]
таким способом в переменные передаются значения следующего массива

==========================================

Функция созданные с помощью этого синтаксиса, являются  <h4>анонимными</h4>
let sum = (a,b,c) =>{  
    return a+b+c
}
sum(5,2,3)
10

==========================================

Если выполняется, что-то в одной строке, то записываем так
let sum = (a,b,c) => a+b+c
undefined
sum(4,5,6)
15
При сокращении строк кода, функционал остается прежним

==========================================

Преимущество строчных функций перед обычными, это сохранение констекста

  
Каждую секунду будем считать интервал увеличения числа на 1
function Person(){
    this.age = 0;
    setInterval(function grow(){ раз в секунду вызывает сам себя
        this.age++; -
        console.log(this.age);
    }, 1000);
}
var p = new Person();
4 NaN Результат в консоле


В этой функции <i>this</i> связаны и функция отрабатывает верно
function Person(){
    this.age = 0;
    setInterval(() =>{
        this.age++; 
        console.log(this.age);
    }, 1000);
}
var p = new Person();

Результат в консоли:

1
2
3
4

==========================================
Функция isNaN

<h3>Старый метод</h3>

let a = "NaN";
let b = NaN;
let c = "hello";
let d = 12;

console.log(isNaN(a));
console.log(isNaN(b));
console.log(isNaN(c));
console.log(isNaN(d));

Результат:
true
true
true
false
С помощью этого значение, можно проверять, что это не число

<h3>Новый метод</h3>
let a = "NaN";
let b = NaN;
let c = "hello";
let d = 12;

console.log(Number.isNaN(a));
console.log(Number.isNaN(b));
console.log(Number.isNaN(c));
console.log(Number.isNaN(d));

Результат:
false
true - вернуло результат, где находится NaN
false
false


==========================================

<h3>В ES6 появились новые тригонометрические формулы</h3>

console.log(Math.sinh(0)); - гиперболический синус
console.log(Math.cosh(0)); - гиперболический косинус
console.log(Math.tanh(0)); - гиперболический тангенс
console.log(Math.asinh(0)); - обратный гиперболический синус
console.log(Math.acosh(1)); - обратный гиперболический косинус
console.log(Math.atanh(0)); - обратный гиперболический тангенс
console.log(Math.hypot(2,2,1)); - теорема Пифагора

<h3>Результат</h3>
0
1
0
0
0
0
3


console.log(Math.log2(16)); - логарифм по основанию 2
console.log(Math.log10(1000)); - логарифм по основанию 10
console.log(Math.log1p(0)); - то же, что и log(1+value)
console.log(Math.expm1(0)); - функция обратная  Math.log1p()
console.log(Math.cbrt(8)); - корень кубический

<h3>Результат</h3>
4
3
0
0
2




==========================================

<h3>Определение у числа знака</h3>
  

console.log(Math.sign(16));
console.log(Math.sign(-16));
console.log(Math.sign(0));


<h3>Результат</h3>
1
-1
0

==========================================

<h3>Методы для работы со строковыми типами данных</h3>

console.log('Str'.repeat(3));
									^ - число повторений
или 
<h3>Результат</h3>

StrStrStr

==========================================

<h3>Новый метод работы с массивами</h3>
let arr = [5,6,7,8]
arr.fill(0) - перезапись массива и внесение нового значения
console.log(arr);

<h3>Результат</h3>
 [0, 0, 0, 0]
 
==========================================

<h3>Метод получения ключей и значение из массива</h3>

let arr = ['a', 'b', 'c']
let entries = arr.entries()
let keys = arr.keys()
let values = arr.values()

console.log(entries);
console.log(keys);
console.log(values);

<h3>Результат</h3>
(2) [0, 'a'] (2) [1, 'b'] (2) [2, 'c'] - 3 массива с выводом ключа и индекса
 0 1 2 - вывод индекса
a b c - вывод ключа

Троеточие - итератор


==========================================
  


let set = new Set();

set.add(1); - добавление значение
set.add(2);  - добавление значение
set.add(3); - добавление значение
set.add(1); - так как повтор значение не возможен, значение не выводится
console.log(set); - вывод результата
console.log(set.has("4")); - проверка определенного значения, поэтому видим <i>false</i>
console.log(set.size); - размер множества
set.delete(2); - удаление определенного элемента
console.log(set); - вывод результата
set.clear() - очистка множества
console.log(set); - вывод результата


<h3>Результат</h3>

Set(3) {1, 2, 3}
false
3
Set(2) {1, 3}
Set(0) {size: 0}

=========================================

Контроль массива на дубликаты значений

let arr = [4,5,6,7,89,5,3,2,1,1];
let arr2 = [...new Set(arr)];

  console.log(arr);
console.log(arr2);

<h3>Результат</h3>

(10) [4, 5, 6, 7, 89, 5, 3, 2, 1, 1]
	0: 41: 52: 63: 74: 895: 56: 37: 28: 19: 1
	length: 10
	[[Prototype]]: Array(0)
 (8) [4, 5, 6, 7, 89, 3, 2, 1]